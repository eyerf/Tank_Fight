日本南梦宫Namco公司的游戏《坦克大战》给童年的我留下了深刻的印象，能亲手做出这样一款游戏也一度成为过我童年的梦想。

仿照着那款游戏，该项目尝试使用java语言实现出这个游戏的绝大部分功能，从基础的游戏的界面，坦克的移动，子弹的发射，到更复杂地图的生成，游戏关卡的配置等等。

下面的内容会对项目内的文件夹，文件及其对应实现的功能做尽量详细的介绍。

## 项目技术总结
该项目基于JavaSE实现，没有设计到框架与中间件，但几乎涵盖了java基础相关的全部技术（除网络编程)，项目总计代码约2500行，具体用到的技术包括：
面相对象特性：封装，继承，多态；设计模式：单例设计模式；awt类包:实现图片绘制；集合：List类，Map类；字符串处理与检测；内部类：坦克的血条；文件IO：配置文件的读取；异常处理；
多线程与线程池：坦克的创建，游戏的结束。反射：通过配置文件读取配置信息，调用方法初始化地图...

## 游戏效果展示
游戏界面菜单:

![本地图片](\gamePhotos\start.png)

关卡1:

![本地图片](\gamePhotos\level_1.png)

关卡2:

![本地图片](\gamePhotos\level_2.png)

游戏结束:

![本地图片](\gamePhotos\end.png)

## level文件夹
level文件夹存储着我设计的全部关卡的信息。

- gameInfo:该文件内保存的是全部关卡的数量
- lv_1-lv_3:文件内保存着敌人数量，种类，地图生成方法，关卡难度的配置信息。level数字越高，对应的地图会更复杂，通关需要击败的敌人会更多，敌人的种类数量也会增加。

通过Properties配置类，我们能读取到关卡的数量和关卡的配置信息，用于生成关卡。通过游戏配置，我们能保证对于代码不用做侵入式修改，直接编辑配置文件即可生成关卡，做到了解耦合。

## music文件夹
该文件夹内存储的是游戏用到的全部的音频文件，文件均来源于网络。

音乐包括了坦克升级，坦克或砖块爆炸（消失），开火，击中音效，以及最最经典的开始游戏时播放的BGM。

## res文件夹
游戏的图片资源文件夹,存储着包括爆照效果，砖块，敌人坦克，自己坦克等等的图片文件资源。

## src
源代码文件夹，实现游戏功能的全部代码均存放在src内。下面我会对src内全部包下的所有类及其实现功能做一个详细的介绍。

### tank_fight.app
- GameMain: 该类是该包下唯一的类。游戏的入口类，通过初始化游戏窗口类引导游戏正式开始，没有其他的功能。

### tank_fight.game
game包中存放的都是和游戏核心相关的类，不同类实现的功能可能有点杂，比如子弹类或者爆炸类，其实也可以单独建立一个包进行存放。下面是对tank_fight.game包下具体类的说明。

**Bullet**:子弹类。一个标准的javabean类，用于创建子弹对象并实现子弹相关的方法。

子弹的静态属性包括了子弹的默认移动速度（坦克速度的两倍）以及子弹的默认半径。

子弹的成员变量具体有子弹的坐标（x, y）, 子弹的移动速度（默认为默认速度），子弹的移动方向，子弹的攻击力，子弹的颜色以及子弹是否可见（在子弹移动出地图之后，子弹就应该被设置为不可见）。

子弹的成员方法这块值得一提的有三个：
- void draw(Graphics g)：该方法用于绘制子弹自身（如果visible属性为false，就不用绘制了）
- void logic()：子弹的逻辑，子弹的逻辑很简单就是移动，但是为了和后面其他类做到同统一，我还是设计了逻辑方法，方法内就调用了子弹的移动方法。
- void move()：子弹的移动方法。根据子弹的方向（dir）属性，判断子弹移动的方向，判断子弹下一帧应该移动的方向（计算子弹下一帧应该处在哪个坐标）。每次子弹移动的距离依据就是子弹的速度属性了，值得一提的是，如果子弹移动出了地图的边界，就应该将子弹的visible属性置为false。

**Explode**:爆照效果类。一个标准的javabean类，用于实现爆炸效果。因为爆炸的效果要实现起来还是挺复杂的（涉及到要加载爆炸的图片），单纯的一个方法不太适合用来实现爆炸效果了，所以我编写了一个类来专门控制爆炸的实现，同时也方便后续代码的复用（爆炸的效果需要在很多地方使用到，比如子弹和坦克碰撞，子弹和砖块碰撞，坦克血量归零之后自爆等等）。

爆炸的静态属性包括了爆炸持续的时间（帧数），爆炸用到的效果图片，以及爆炸图片的大小。在初始化类时，将爆炸需要的资源图片导入到了静态变量中。

爆炸的成员变量包括了爆炸的具体坐标，爆炸效果当前处于的帧数（爆炸也可以理解为一个动画的播放，当前的爆炸具体处于第几帧），以及当前爆炸是否可见（播放结束，爆炸不可见)。

爆炸类的成员方法只有一个：
- draw(Graphics g)：根据爆炸图片的宽，高，绘制出爆炸图片。在绘制完最后一帧以后，将爆炸设置为不可见。

**GameFrame**:游戏的主窗口类，也是游戏的核心类，游戏中所有展示的内容都会在该类中实现

GameFrame的静态变量:
- int gameState:游戏状态
- int menuIndex:菜单状态索引（被指向的选项高亮表示）
- int titleBarH：标题栏的高度
- Tank myTank：自己的坦克对象
- List<Tank> enemies：敌人的坦克容器
- int bornEnemyCount：统计本关卡一共出现的敌人数量
- int killEnemyCount：已击败的敌人数量
- GameMap gameMap：游戏地图

GameFrame的构造方法:由启动类GameMain进行调用，初始化游戏，初始化游戏的开始窗口界面，初始化对于游戏开始界面窗口的监听，并启动一个线程开始刷新窗口

GameFrame的成员方法:
- static void startGame(int level): 游戏开始的核心方法，首先清空敌人的容器，然后初始化地图，播放开始游戏的音乐，改变游戏状态为Constant.STATE_RUN，创建自己的坦克对象，最后创建一个单独的线程，用于去定时生产敌人的坦克
- void initGame():对游戏进行初始化,将游戏状态设置为STATE_MENUE（菜单界面）
- void initFrame(): 对游戏属性进行初始化，设置标题，设置窗口大小，设置窗口的左上角的坐标，设置窗口大小不可改变，设置窗口可见
- void update(Graphics g1): 是Frame类继承下来的方法,该方法负责了所有的绘制的内容，所有需要在屏幕中显示的内容，都要在该方法中调用。该方法不能主动调用。必须通过调用repaint()去回调该方法
- void drawLost(Graphics g, String str): 绘制游戏结束的方法
- void drawWin(Graphics g):绘制游戏胜利的界面
- void drawRun(Graphics g): 游戏运行状态的绘制内容,包括黑色的背景，地图的碰撞层，地图的遮挡层，同时调用子弹和坦克的碰撞的方法，子弹和所有的地图块的碰撞方法进行碰撞检测
- void drawEnemies(Graphics g):绘制所有的敌人的坦克, 但是如果敌人已经死亡，就需要从容器中移除它
- void drawMenu(Graphics g)：绘制菜单状态下的内容，包括黑色的背景，菜单中的选项（选中菜单项的颜色设置为红色），其他的为白色
- void initEventListener()：初始化窗口的事件监听,添加按键监听事件,获取被被按下键的键值(或者松开的键值)，不同的游戏状态，需要给出不同的处理方法
- void keyPressedEventWin(int keyCode):游戏通关的按键处理
- void keyReleasedEventRun(int keyCode):按键松开的时候，游戏中的处理方法(将坦克状态设置为站立)
- void keyPressedEventLost(int keyCode): 游戏结束的按键处理,需要退出游戏，或者重回菜单，同时调用resetGame()重置游戏状态
- void resetGame()：重置游戏状态，将所有属性初始化到最初的状态，先让自己的坦克的子弹还回对象池在销毁自己的坦克，清空所有敌人与敌人子弹，清空地图资源
- void keyPressedEventRun(int keyCode):游戏运行中的按键的处理方法,改变坦克的状态，或者让坦克开火
- void keyPressedEventMenu(int keyCode): 菜单状态下的按键的处理,上下左右移动菜单选项，按下回车键，执行选项对应的功能
- void run(): GameFrame继承了Thread类，需要重写run方法，每隔一定的时间间隔调用repaint()方法来刷新窗口
- void bulletCollideTank()：子弹和坦克碰撞的检测（敌人的坦克的子弹和我的坦克的碰撞，我的坦克的子弹和所有的敌人的碰撞）
- void bulletAndTankCollideMapTile()： 所有的子弹和坦克和地图块的碰撞检测，同时实现清理被销毁的地图块的功能
- drawExplodes(Graphics g)： 所有的坦克上的爆炸效果的绘制
- drawCross(Graphics g)： 绘制过关动画，这里实现了一个百叶窗的效果来用于绘制过关的动画。（百叶窗先关闭，再打开）。

**GameInfo**:游戏相关的信息的类，这里主要是从配置文件中读取到配置的关卡数量，并提供方法给其他类获取

**LevelInfo**:用来管理当前关卡信息的一个单例类
单例设计模式：如果一个类只需要该类具有唯一的实例，那么可以使用单例设计模式来设计该类

LevelInfo的静态变量:
- private static LevelInfo instance： 定义静态的本类类型的变量，来指向唯一的实例

LevelInfo的成员变量：
- private int level: 关卡的编号
- private int enemyCount: 关卡的敌人的数量
- private int crossTime = -1 : 通关的要求的时长, -1 意味着不限时
- private int[] enemyType: 敌人的类型
- private int levelType: 游戏的难度, 一个大于等于1的值

LevelInfo的成员方法：
- public static LevelInfo getInstance(): 该静态方法返回懒汉模式的单例，我们在第一次使用该实例的时候创建唯一的实例，所有的访问该类的唯一实例都是通过该方法（该方法具有安全隐患，多线程的情况下可能会创建多个实例）
- public int getRandomEnemyType()：获得敌人类型数组中的随机的一个元素，获得一个随机的敌人类型

### tank_fight.map
意如其名，map包中存放的都是跟游戏地图和砖块相关的类，包括了游戏的地图，游戏会用到的砖块，以及我们玩家的主基地（~~老窝~~）

**GameMap**:游戏地图类,通过该类实现游戏地图的加载，地图上砖块的管理和游戏地图的初始化。值得一提的是，该类通过读取配置文件中的关卡信息，通过java反射来生成关卡对应的砖块，进而生成关卡。

**MapTile**:地图元素块类。通过该类来管理游戏中会出现的全部的地图元素块（砖块，实心块，绿草块等等），值得一提的是该类实现了**isCollideBullet**方法，判断地图块是否有和子弹发生碰撞，
若发生了碰撞，就销毁子弹（visible=false）同时根据砖块的种类判断是否要销毁砖块

**MapTile**:：玩家的大本营，因为大本营是固定的，在静态代码块中就初始化并绘制了核心块和核心周围一圈的砖块。

### tank_fight.tank

**EnemyTank**:敌人坦克类，继承了Tank类，加载了敌人坦克的图片和其他的一些配置信息，值得一提的是该类提供的两个方法：

- public static Tank creatEnemy()：该方法用于创建一个敌人的坦克，需要根据游戏的难度，设置敌人的血量，同时通关关卡信息中的敌人类型，来设置当前出生的敌人的类型
- private void ai()：该方法模拟了敌人的简单AI，每间隔5秒随机给敌人设置一个状态，同时根据难度，设置随机开火的概率

**MyTank**:玩家坦克类，主要加载了玩家坦克的图片，和配置信息

**Tank**:坦克类。是敌人坦克和玩家坦克的父类，提供实现了坦克所包括的全部的静态，成员变量与方法。

坦克类同时保存着坦克发射的子弹的容器，已经当前坦克上的所有的爆炸效果。

实现的方法中，值得一提的包括了：
- private void move(): 坦克移动的功能
- public void fire(): 坦克开火的功能，创建了一个子弹对象（从对象池中获取子弹对象），子弹对象的属性信息通过坦克的信息获得，然后将创建的子弹添加到坦克管理的容器中
- public void collideBullets(List<Bullet> bullets)： 坦克和子弹碰撞的方法，遍历所有的子弹，依次和当前的坦克进行碰撞的检测，子弹和坦克碰上了，子弹消失，坦克受到伤害并添加爆炸效果
- private void die()： 坦克死亡需要处理的内容。敌人坦克被消灭了归还对象池，判断本关是否结束了，判断游戏是否通关，判断游戏是否通关。如果是己方坦克被消灭则游戏结束。
- public void bulletsCollideMapTiles(List<MapTile> tiles)： 坦克的子弹和地图所有块的碰撞
- private void delaySecondsToOver(int millisSecond)： 开启一个新的线程，延迟若干毫秒后切换到游戏结束
- public boolean isCollideTile(List<MapTile> tiles): 一个地图块和当前的坦克碰撞的方法, 从tile中提取8个点，来判断8个点中是否有任何一个点和当前的坦克发生了碰撞, 点的顺序从左上角开始，顺时针遍历, 如果是块不可见，或者是遮挡块，就不进行碰撞的检测, 如果碰上了就直接返回，否则就继续判断下一个点

同时坦克类还管理着一个内部类：BloodBar, 用于表示坦克的血条，并绘制出来

### tank_fight.util
util包中主要是对于一些工具类和对象池进行了实现，同时也管理者常量池。

**BulletPool**:子弹对象池类。创建了一个静态的容器来管理所有的子弹对象，在类加载的时候创建200个子弹对象添加到容器中。
- public static Bullet get()： 从池塘中获取一个子弹对象（假如池塘被掏空了，就再创建新的对象）。池塘中还有对象，拿走第一个位置的子弹对象。
- public static void theReturn(Bullet bullet)：子弹被销毁的时候，归还到池塘中来。（池塘中的子弹的个数已经到达了最大值，那就不在归还）

**EnemyTanksPool**: 敌人坦克的对象池，实现的方法类似子弹对象池类。

**ExplodesPool**: 爆照的对象池，实现的方法类似子弹对象池类。

**MapTilePool**: 地图的砖块对象池，实现的方法类似子弹对象池类。

**MusicUtil**:音乐工具类，读取音效资源并提供方法进行播放

**Util**:工具类，实现包括获取随机数，加载图片资源，生成坦克名字的静态方法

**Constant**:游戏中用到的常量都在该类中维护，方便后期的管理

### process.txt
该文本保存了我实现该项目时具体的实现步骤与思路。

